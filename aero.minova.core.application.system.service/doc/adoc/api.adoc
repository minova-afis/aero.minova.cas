= CAS API

Konkrete Beispiele sind in einer xref:../../aero.minova.service.core.application.system.postman_collection.json#[Postman Collection] gelistet.
Die Authentifizierung findet über Basic Auth statt.

== Table

Die Table ist eine grundsätzliche Datenstruktur und wird als Teil der Eingabe und Ausgabe verwendet.

Generell gilt, dass jedes Feld bis auf metaData ein Pflichtfeld ist.
Die jeweiligen values müssen genauso viele Werte haben wie columns.

[source,json]
--------
{
	"name": "ProcedureName",
	"metaData": 
		{
        	"limited": 10,
        	...
    	},
	"columns": [
		{
			"name": "ParameterName",
			"type": "BOOLEAN|DOUBLE|INSTANT|INTEGER|STRING|ZONED",
			"outputType": "INPUT|OUTPUT"
		},...
	],
	"rows": [
		{
			"values": [
				"(f-Operator-(b|d|i|n|s|z)-Value)|"
				"(r-ReferenzId-ReferenzColumn)|"
				"(b|d|i|n|s|z-Value)|"
				"null",...
			]
		}
	]
}
--------

<<Im Fehlerfall>> erweitert sich die Ausgabe-Table um einen weiteren Parameter.

=== name

Der Name der Prozedur, die ausgeführt wird.

=== metaData

----
	"metaData": 
		{
        	"limited": 10,
        	"page": 1,
        	"totalResults": 10,
        	"totalPages": 1,
        	"resultsLeft": 0
    	},
----

Anhand von metaData kann man die sichtbare Ergebnissemenge einschränken.
Dies ist durch die Parameter limited und page möglich.

.veränderbare Parameter:
* *limited*: Anzahl an Treffern, welche bei der Anfrage zurückgegeben werden sollen.
Ist der Wert 0, werden alle Treffer zurückgegeben und der Wert der totalResults angezeigt.
* *page*: die n-te Seite der totalPages basierend auf limited.
Ist kein Wert für page gesetzt, werden die Ergebnisse von 0 bis limited,
also die 1.Seite, ausgegeben.

.unveränderbare/vom Service berechnete Parameter:
* *totalResults*: Anzahl an Rows, welche für die angegebenen Suchparameter gefunden wurden.
* *totalPages*: Anzahl an Seiten, welche basierend auf den totalResults und limited errechnet wurden.
* *resultsLeft*: Anzahl an Rows, welche nach der momentanen Seite noch übrig sind.

=== columns

Die Parameter-Typen das Aufrufes.

==== columns/values/*

Die Werte dürfen prinzipiell von einem beliebigen Typ sein,
müssen aber mit dem Typ der jeweiligen Spalte kompatibel sein.
Im einfachsten Fall ist der Typ eines Values gleich dem Typ der jeweiligen Spalte (columns/*/type).

Der Typ wird anhand des Prefixes des Values angegeben:

* *"b"*: boolean: false|true
* *"d"*: double: Entspricht dem Format von "java.lang.Double.parseDouble(String)".
* *"i"*: Instant (UTC-Zeit): Entspricht dem Format von "java.time.Instant.parse(String)".
* *"n"*: Integer: Entspricht dem Format von "java.lang.Integer.parseInt(String)".
* *"s"*: String
* *"z"*: ZonedDateTime: Entspricht dem Format von "java.time.ZonedDateTime.parse(String)".
* *"m"*: Money: Entspricht dem Format von "java.math.BigDecimal.valueOf(Double.parseDouble(String))".
* *"f"*: Filter: Zeigt an, dass ein Operator mit angegeben wurde.
* *"r"*: Referenz: Zeigt an, dass eine Referenz auf das Ergebnis einer anderen Prozedur innerhalb der Anfrage besteht.
  
Durch den Prefix "f-" können die Operatoren *<> , <=, >=, <, >, =, between(), in(), !~, ~, null* und *!null* bei der Eingabe verwendet werden.

=== rows

Die Parameter der Prozedur.

== data/procedure

Führt eine Prozedur auf dem Server aus.
Häufig ist dies eine SQL-Prozedur auf dem SQL-Server.

Der Nutzer innerhalb der SQL-Prozedur sollte nicht über `user_name()` bestimmt werden,
da damit nur der SQL-Nutzer vom CAS ermittelt wird.
Dieser ist immer derselbe.
Stattdessen wird der Nutzer vor jedem Prozeduraufruf im SQL-Session-Context abgespeichert
und kann mit der entsprechenden Funktion abgerufen werden: `xfCasUser()`

=== Eingabe

Als Eingabe wird eine Table im Body der Get-Anfrage erwartet.

Diese Table enthält die Parameter für die SQL-Prozedur und optional Metadaten.
Die columns beschreiben den Namen und den Typ der Argumente.
Die rows enthalten eine Zeile, in der die Argumente gelistet sind.

=== Ausgabe

Die Antwort hat bei Erfolg folgendes Format:

[source,json]
--------
{
	"resultSet": <Table>,
	"outputParameters": <Table>,
	"returnCode": <Integer>
}
--------

Bei Misserfolg siehe Kapitel <<Im Fehlerfall>>

==== resultSet

Gibt im Table-Format alle selektierten Werte zurück.
Werden keine Werte selektiert, wird die Tabelle in der Antwort nicht angegeben.

==== outputParameters

Gibt im Table-Format alle Input und Output-Parameter-Werte zurück, wenn es einen Output-Parameter in der Eingabe gab.
Diese Tabelle enthält nur 1 Zeile.

==== returnCode

Der Return Code der SQL-Prozedur, falls vorhanden.
Bei Erfolg ist er entweder 0 oder positiv. Bei Misserfolg negativ.

=== Spezielle Prozeduren

Es gibt die Prozedur `Ticket`, welche durch das CAS bereitgestellt wird.
Diese sucht anhand der Ticketnummer nach den Daten des Tickets im Trac
und im SQL-Server.

[source,json]
.Als Parameter muss die `TicketNumber` übergeben werden, wobei das Ticket -123 ein nicht existierendes Test-Ticket ist, welches immer abrufbar ist:
--------
{
    "name": "Ticket",
    "columns": [
        {
            "name": "TicketNumber",
            "type": "INTEGER",
            "outputType": "OUTPUT"
        }
    ],
    "rows": [
        {
            "values": [
                "s--123"
            ]
        }
    ]
}
--------

[source,json]
.Als Antwort bekommt man die Details des Tickets zurück.
----
{
    "resultSet": {
        "name": "Ticket",
        "columns": [
            {
                "name": "TicketKey",
                "type": "INTEGER"
            },
            {
                "name": "OrderReceiver",
                "type": "STRING"
            },
            {
                "name": "ServiceContract",
                "type": "STRING"
            },
            {
                "name": "ServiceObject",
                "type": "STRING"
            },
            {
                "name": "Service",
                "type": "STRING"
            },
            {
                "name": "Description",
                "type": "STRING"
            },
            {
                "name": "OrderReceiverKey",
                "type": "INTEGER"
            },
            {
                "name": "ServiceContractKey",
                "type": "INTEGER"
            },
            {
                "name": "ServiceObjectKey",
                "type": "INTEGER"
            },
            {
                "name": "ServiceKey",
                "type": "INTEGER"
            }
        ],
        "rows": [
            {
                "values": [
                    "n--123",
                    "s-MIN",
                    "s-WFC",
                    "s-LOHN",
                    "s-ZPROGRAM",
                    "s-#37: Trac-Ticket Dummy Implementierung auf publictest bereitstellen.",
                    null,
                    null,
                    null,
                    null
                ]
            }
        ]
    }
}
----

== data/view

Selektiert Objekte (View, Tabelle, etc.) des SQL-Servers.

Als Ausgabe wird eine Table mit den selektierten Werten zurückgegeben.

Als Eingabe wird eine Table im Body der Get-Anfrage erwartet.
Die Eingabe-Tabelle schränkt die Auswahl der selektierten Werte ein.
Das Format der Eingabe entspricht der Beschreibung aus https://github.com/minova-afis/aero.minova.rcp/tree/master/bundles/aero.minova.rcp.model

== /ping

Hiermit kann man die Verbindung und die Anmeldedaten prüfen.
Hat keine Eingabe und gibt als Antwort ein JSON-Object mit einem Return Code von 0 zurück,
wenn alles gut gelaufen ist.

[source,json]
--------
{
	"returnCode":1
}
--------

== Im Fehlerfall

Ist die Eingabe fehlerhaft oder treten sonstige Fehler bei der Verarbeitung des Services auf,
wird an den Client ein *Internal Server Error*, bzw. *Server Code 500*, gesendet.

Auf dem *Server* wird in der Tabelle xtcasError ein Eintrag mit dem Username, dem genauen Zeitpunkt und dem aufgetretenen Fehler erstellt.
[source,sql]
----
insert into xtcasError (Username, ErrorMessage, Date) values (username,errorMessage,date)
----


Das Rückgabeformat der Tabelle, welche an den *Client* gesendet wird, ändert sich wie folgt: 

[source,sql]
----
{
	"name": "Error",
    "columns": [
        {
            "name": "International Message",
            "type": "STRING"
        }
        [,{
        	"name": "MessageInputParam1",
            "type": "STRING"
            }]
    ],
    "rows": [
        {
            "values": [
                "s-msg.Error",["s-InputParameter",...]
            ]
        }
    ],
	"returnErrorMessage": {
		"detailsMessage": "ExceptionMessage",
		"cause": "ExceptionCause",
		"trace": [ 
			"StackTraceMessages",
			...
		]
	} 
----
Der Name der zurückgegebenen Tabele wird auf "Error" geändert und es wird nur eine Row zurückgegeben,
in welcher der übersetzbare MessageCode hinterlegt ist, welcher beim Client in die Sprache des Users übersetzt wird.
Falls die Nachricht einen oder mehrere Inputparameter benötigt, folgen weitere String-Values, welche die einzelnen Parameter enthalten.

Die returnErrorMessage beinhaltet immer eine detailsMessage, einen cause und einen trace.

Sie wird nur befüllt, falls ein Fehler auftritt. 
Ansonsten ist dieses Objekt *null*.

==== returnErrorMessage/detailsMessage

Die DetailsMessage der Exception, die geworfen wurde.

==== returnErrorMessage/cause

Der Grund, weshalb die Exception geworfen wurde, z.b.:
_java.lang.NullPointerException_.

==== returnErrorMessage/trace

Der StackTrace der geworfenen Exception nach jedem Abatz getrennt.
